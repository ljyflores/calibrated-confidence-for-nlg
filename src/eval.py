import numpy as np
import re
import string

from collections import Counter
from evaluate import load  # type: ignore
from rouge_score import rouge_scorer, scoring  # type: ignore
from typing import List

metric_bertscore = load("bertscore")  # type: ignore
metric_sari = load("sari")  # type: ignore
metric_meteor = load("meteor")  # type: ignore
metric_bleu = load("bleu")  # type: ignore


def calculate_bleu(predictions: List[str], references: List[List[str]]):
    results_bleu = metric_bleu.compute(predictions=predictions, references=references)  # type: ignore
    if results_bleu:
        return float(results_bleu["bleu"])  # type: ignore
    else:
        raise ValueError("Error in computing BLEU")


def calculate_meteor(predictions: List[str], references: List[List[str]]):
    results_meteor = metric_meteor.compute(  # type: ignore
        predictions=predictions, references=references
    )
    if results_meteor:
        return float(results_meteor["meteor"])  # type: ignore
    else:
        raise ValueError("Error in computing METEOR")


def calculate_rouge(
    predictions: List[str],
    references: List[List[str]],
):
    """Calculate rouge using rouge_scorer package.
    Args:
        pred_lns: list of summaries generated by model
        tgt_lns: list of groundtruth summaries (e.g. contents of val.target)
    Returns:
         Dict[score: value] if aggregate else defaultdict(list) keyed by rouge_keys
    """
    scorer = rouge_scorer.RougeScorer(
        ["rouge1", "rouge2", "rougeL", "rougeLsum"], use_stemmer=True
    )
    aggregator = scoring.BootstrapAggregator()
    for pred, tgt in zip(predictions, references):
        scores = scorer.score_multi(tgt, pred)  # type: ignore
        aggregator.add_scores(scores)  # type: ignore

    result = aggregator.aggregate()  # type: ignore
    return {str(k): float(v.mid.fmeasure * 100) for k, v in result.items()}  # type: ignore


def calculate_bertscore(predictions: List[str], references: List[List[str]]):
    result_bert = list[float]()
    for pred, label in zip(predictions, references):
        bertscore_dict = metric_bertscore.compute(  # type: ignore
            predictions=[pred] * len(label), references=label, lang="en"
        )
        if bertscore_dict:
            if isinstance(bertscore_dict["f1"], list):
                result_bert.append(float(bertscore_dict["f1"][0]))  # type: ignore
            else:
                result_bert.append(float(bertscore_dict["f1"]))  # type: ignore

    return float(np.mean(result_bert))


def calculate_sari(
    sources: List[str], predictions: List[str], references: List[List[str]]
):
    sari_result_dict = metric_sari.compute(  # type: ignore
        sources=sources or [],
        predictions=predictions or [],
        references=references or [],
    )
    return float(sari_result_dict["sari"]) or None  # type: ignore


def clean_string(s: str):
    s = s.replace("-lrb-", " ").replace("-rrb-", " ")
    s = s.replace("<s>", "").replace("</s>", "").replace("<pad>", "")
    return re.sub(" +", " ", s)


def normalize_answer(s: str):
    """Lower text and remove punctuation, articles and extra whitespace."""

    def remove_articles(text: str):
        return re.sub(r"\b(a|an|the)\b", " ", text)

    def white_space_fix(text: str):
        return " ".join(text.split())

    def remove_punc(text: str):
        exclude = set(string.punctuation)
        return "".join(ch for ch in text if ch not in exclude)

    def lower(text: str):
        return text.lower()

    return white_space_fix(remove_articles(remove_punc(lower(s))))


def calculate_f1_score(prediction: str, ground_truth: str):
    prediction_tokens = normalize_answer(prediction).split()
    ground_truth_tokens = normalize_answer(ground_truth).split()
    common = Counter(prediction_tokens) & Counter(ground_truth_tokens)
    num_same = sum(common.values())
    if num_same == 0:
        return 0
    precision = 1.0 * num_same / len(prediction_tokens)
    recall = 1.0 * num_same / len(ground_truth_tokens)
    f1 = (2 * precision * recall) / (precision + recall)
    return f1
